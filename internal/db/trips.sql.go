// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: trips.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const completeTrip = `-- name: CompleteTrip :exec
UPDATE trips
SET
end_time = $2,
end_photo_url = $3,
travelled_meters = $4,
completed_at = $5
WHERE id = $1
`

type CompleteTripParams struct {
	ID              pgtype.UUID
	EndTime         pgtype.Timestamptz
	EndPhotoUrl     pgtype.Text
	TravelledMeters pgtype.Int4
	CompletedAt     pgtype.Timestamptz
}

func (q *Queries) CompleteTrip(ctx context.Context, arg CompleteTripParams) error {
	_, err := q.db.Exec(ctx, completeTrip,
		arg.ID,
		arg.EndTime,
		arg.EndPhotoUrl,
		arg.TravelledMeters,
		arg.CompletedAt,
	)
	return err
}

const createTrip = `-- name: CreateTrip :one
INSERT INTO trips (
driver_id, company_id, start_time, start_photo_url
)
VALUES ($1, $2, $3, $4)
RETURNING id, driver_id, company_id, start_time, end_time, travelled_meters, start_photo_url, end_photo_url, created_at, completed_at
`

type CreateTripParams struct {
	DriverID      pgtype.UUID
	CompanyID     pgtype.UUID
	StartTime     pgtype.Timestamptz
	StartPhotoUrl pgtype.Text
}

func (q *Queries) CreateTrip(ctx context.Context, arg CreateTripParams) (Trip, error) {
	row := q.db.QueryRow(ctx, createTrip,
		arg.DriverID,
		arg.CompanyID,
		arg.StartTime,
		arg.StartPhotoUrl,
	)
	var i Trip
	err := row.Scan(
		&i.ID,
		&i.DriverID,
		&i.CompanyID,
		&i.StartTime,
		&i.EndTime,
		&i.TravelledMeters,
		&i.StartPhotoUrl,
		&i.EndPhotoUrl,
		&i.CreatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const deleteTrip = `-- name: DeleteTrip :exec
DELETE FROM trips
WHERE id = $1
`

func (q *Queries) DeleteTrip(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteTrip, id)
	return err
}

const getOngoingTripByDriver = `-- name: GetOngoingTripByDriver :one
SELECT id, driver_id, company_id, start_time, end_time, travelled_meters, start_photo_url, end_photo_url, created_at, completed_at FROM trips
WHERE driver_id = $1
AND end_time IS NULL
ORDER BY start_time DESC
LIMIT 1
`

func (q *Queries) GetOngoingTripByDriver(ctx context.Context, driverID pgtype.UUID) (Trip, error) {
	row := q.db.QueryRow(ctx, getOngoingTripByDriver, driverID)
	var i Trip
	err := row.Scan(
		&i.ID,
		&i.DriverID,
		&i.CompanyID,
		&i.StartTime,
		&i.EndTime,
		&i.TravelledMeters,
		&i.StartPhotoUrl,
		&i.EndPhotoUrl,
		&i.CreatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const getTripByID = `-- name: GetTripByID :one
SELECT id, driver_id, company_id, start_time, end_time, travelled_meters, start_photo_url, end_photo_url, created_at, completed_at FROM trips
WHERE id = $1
`

func (q *Queries) GetTripByID(ctx context.Context, id pgtype.UUID) (Trip, error) {
	row := q.db.QueryRow(ctx, getTripByID, id)
	var i Trip
	err := row.Scan(
		&i.ID,
		&i.DriverID,
		&i.CompanyID,
		&i.StartTime,
		&i.EndTime,
		&i.TravelledMeters,
		&i.StartPhotoUrl,
		&i.EndPhotoUrl,
		&i.CreatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const listTripsByCompany = `-- name: ListTripsByCompany :many
SELECT id, driver_id, company_id, start_time, end_time, travelled_meters, start_photo_url, end_photo_url, created_at, completed_at FROM trips
WHERE company_id = $1
ORDER BY start_time DESC
LIMIT $2 OFFSET $3
`

type ListTripsByCompanyParams struct {
	CompanyID pgtype.UUID
	Limit     int32
	Offset    int32
}

func (q *Queries) ListTripsByCompany(ctx context.Context, arg ListTripsByCompanyParams) ([]Trip, error) {
	rows, err := q.db.Query(ctx, listTripsByCompany, arg.CompanyID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Trip
	for rows.Next() {
		var i Trip
		if err := rows.Scan(
			&i.ID,
			&i.DriverID,
			&i.CompanyID,
			&i.StartTime,
			&i.EndTime,
			&i.TravelledMeters,
			&i.StartPhotoUrl,
			&i.EndPhotoUrl,
			&i.CreatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTripsByDriver = `-- name: ListTripsByDriver :many
SELECT id, driver_id, company_id, start_time, end_time, travelled_meters, start_photo_url, end_photo_url, created_at, completed_at FROM trips
WHERE driver_id = $1
ORDER BY start_time DESC
LIMIT $2 OFFSET $3
`

type ListTripsByDriverParams struct {
	DriverID pgtype.UUID
	Limit    int32
	Offset   int32
}

func (q *Queries) ListTripsByDriver(ctx context.Context, arg ListTripsByDriverParams) ([]Trip, error) {
	rows, err := q.db.Query(ctx, listTripsByDriver, arg.DriverID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Trip
	for rows.Next() {
		var i Trip
		if err := rows.Scan(
			&i.ID,
			&i.DriverID,
			&i.CompanyID,
			&i.StartTime,
			&i.EndTime,
			&i.TravelledMeters,
			&i.StartPhotoUrl,
			&i.EndPhotoUrl,
			&i.CreatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTripsByPeriod = `-- name: ListTripsByPeriod :many
SELECT id, driver_id, company_id, start_time, end_time, travelled_meters, start_photo_url, end_photo_url, created_at, completed_at FROM trips
WHERE driver_id = $1
AND start_time >= $2
AND end_time <= $3
ORDER BY start_time DESC
`

type ListTripsByPeriodParams struct {
	DriverID  pgtype.UUID
	StartTime pgtype.Timestamptz
	EndTime   pgtype.Timestamptz
}

func (q *Queries) ListTripsByPeriod(ctx context.Context, arg ListTripsByPeriodParams) ([]Trip, error) {
	rows, err := q.db.Query(ctx, listTripsByPeriod, arg.DriverID, arg.StartTime, arg.EndTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Trip
	for rows.Next() {
		var i Trip
		if err := rows.Scan(
			&i.ID,
			&i.DriverID,
			&i.CompanyID,
			&i.StartTime,
			&i.EndTime,
			&i.TravelledMeters,
			&i.StartPhotoUrl,
			&i.EndPhotoUrl,
			&i.CreatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const totalMetersByDriver = `-- name: TotalMetersByDriver :one
SELECT COALESCE(SUM(travelled_meters), 0) AS total_meters
FROM trips
WHERE driver_id = $1
`

func (q *Queries) TotalMetersByDriver(ctx context.Context, driverID pgtype.UUID) (interface{}, error) {
	row := q.db.QueryRow(ctx, totalMetersByDriver, driverID)
	var total_meters interface{}
	err := row.Scan(&total_meters)
	return total_meters, err
}
